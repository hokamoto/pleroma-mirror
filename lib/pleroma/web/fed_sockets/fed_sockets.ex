defmodule Pleroma.Web.FedSockets do
  @moduledoc """
  This documents the FedSockets framework. A framework for transferring
  ActivityPub objects between servers via persistant WebSocket connections.

  FedSockets allow servers to authenticate on first contact and maintain that
  connection, eliminating the need to authenticate every time data needs to move.

  ## Protocol
  FedSockets currently support 2 types of data transfer:
    * `publish` method which doesn't require a response
    * `fetch` method requires a response be sent

    ### Publish
    The publish operation sends a json encoded map of the shape:
      %{action: :publish, data: json}
    and accepts (but does not require) a reply of form:
      %{"action" => "publish_reply"}

    The outgoing params represent
      * data: ActivityPub object encoded into json


    ### Fetch
    The fetch operation sends a json encoded map of the shape:
      %{action: :fetch, data: id, uuid: fetch_uuid}
    and requires a reply of form:
      %{"action" => "fetch_reply", "uuid" => uuid, "data" => data}

    The outgoing params represent
      * id: an ActivityPub object URI
      * uuid: a unique uuid generated by the sender

    The reply params represent
      * data: an ActivityPub object encoded into json
      * uuid: the uuid sent along with the fetch request

  ## Examples
  Clients of FedSocket transfers shouldn't need to use any of the functions outside of this module.

  A typical publish operation can be performed through the following code, and a fetch operation in a similar manner.

    case FedSockets.get_or_create_fed_socket(inbox) do
      {:ok, fedsocket} ->
        FedSockets.publish(fedsocket, json)

      _ ->
        alternative_publish(inbox, actor, json, params)
    end

  ## Configuration
  FedSockets have the following config settings

  config :pleroma, :fed_sockets,
  enabled: true,
  ping_interval: :timer.seconds(15),
  connection_duration: :timer.hours(1),
  rejection_duration: :timer.hours(1),
  fed_socket_fetches: [
    default: 12_000,
    interval: 3_000,
    lazy: false
  ]
    * enabled - turn FedSockets on or off with this flag. Can be toggled at runtime.
    * ping_interval - How often messages are exchanged by FedSocket connections to avoid timeouts
    * connection_duration - How long a FedSocket can sit idle before it's culled.
    * rejection_duration - After failing to make a FedSocket connection a host will be excluded
    from further connections for this amount of time
    * fed_socket_fetches - Use this paramteres to pass options to the Caches queue backing the FetchRegistry
      * default: the minimum amount of time a fetch can wait before it times out.
      * interval: the interval between checks for timed out fetches. This plus the default represent the maximum time allowed
      * lazy: leave at false for consistant and fast lookups, set to true for stricter timeout enforcement

  """
  require Logger

  alias Pleroma.Web.FedSockets.FedRegistry
  alias Pleroma.Web.FedSockets.FedSocket
  alias Pleroma.Web.FedSockets.SocketInfo

  @doc """
  returns a FedSocket for the given origin. Will reuse an existing one or create a new one.

  address is expected to be a fully formed URL such as:
  "http://www.example.com" or "http://www.example.com:8080"

  It can and usually does include additional path parameters,
  but these are ignored as the FedSockets are organized by host and port info alone.
  """
  def get_or_create_fed_socket(address) do
    origin = SocketInfo.origin(address)

    with {:cache, {:error, :missing}} <- {:cache, get_fed_socket(address)},
         {:connect, {:ok, fed_socket}} <- {:connect, FedSocket.connect_to_host(origin)},
         {:register, {:ok, fed_socket}} <- {:register, FedRegistry.add_fed_socket(fed_socket)} do
      IO.puts("#{inspect(self())} - FedSocket created for - #{address}")
      {:ok, fed_socket}
    else
      {:cache, {:ok, socket}} ->
        {:ok, socket}

      {:connect, {:error, _host}} ->
        IO.puts("set host rejected #{inspect(origin)}")
        FedRegistry.set_host_rejected(origin)
        {:error, :rejected}

      {_, {:error, reason}} ->
        {:error, reason}
    end
  end

  @doc """
  returns a FedSocket for the given origin. Will not create a new FedSocket if one does not exist.

  address is expected to be a fully formed URL such as:
    "http://www.example.com" or "http://www.example.com:8080"
  """
  def get_fed_socket(address) do
    origin = SocketInfo.origin(address)

    with {:config, true} <- {:config, Pleroma.Config.get([:fed_sockets, :enabled], false)},
         {:ok, socket} <- FedRegistry.get_fed_socket(origin) do
      IO.puts("#{inspect(self())} - FedSocket retrieved for - #{origin}")
      {:ok, socket}
    else
      {:config, _} ->
        {:error, :disabled}

      {:error, :rejected} ->
        IO.puts("FedSocket previously rejected - #{origin}")
        {:error, :rejected}

      {:error, reason} ->
        {:error, reason}
    end
  end

  @doc """
  Sends the supplied data via the publish protocol.
  It will not block waiting for a reply.
  Returns :ok but this is not an indication of a successful transfer.

  the data is expected to be JSON encoded binary data.
  """
  def publish(%FedSocket{} = fed_socket, json) do
    FedRegistry.touch(fed_socket)
    FedSocket.publish(fed_socket, json)
  end

  @doc """
  Sends the supplied data via the fetch protocol.
  It will block waiting for a reply or timeout.

  Returns {:ok, object} where object is the requested object (or nil)
          {:error, :timeout} in the event the message was not responded to

  the id is expected to be the URI of an ActivityPub object.
  """
  def fetch(%FedSocket{} = fed_socket, id) do
    FedRegistry.touch(fed_socket)
    FedSocket.fetch(fed_socket, id)
  end

  @doc """
  Closes the given FedSocket on both sides of the transfer.
  Since idle transfer timeout and active transfers will just reconnect
  it should not be necessary to call this under normal circumstances.
  """
  def close(%FedSocket{} = fed_socket) do
    Logger.debug("closing socket")
    FedSocket.close(fed_socket)
  end

  @doc """
  Disconnect all and restart FedSockets.
  This is mainly used in development and testing but could be useful in production.
  """
  def reset do
    FedRegistry
    |> Process.whereis()
    |> Process.exit(:testing)
  end
end
